This defines infromaly fromaly the elm grammar

# Notes

## Syntax

All terminal characters are shown bare,
nonterminals are delimited in /Slashes/
I also use <Angled brackets>+ as grouping.
When something is followed by a
: + it appears one or more times
: * it appears zero to N times
: ? it appears zero or one time

## Newline handling

The Newline handling is a bit wonky: Mostly, only Newlines followed by
a token starting at the first column are of meaning, but inside expressions
they are important.

Getting rid of meaningless newline tokens is extremly useful for parsing,
but we need to know when to do so. What I did to handle them is that:

* Have a "pre-parse" phase dividing the token stream in N top level
  declarations (divide on N0).

* Depending on which part of the source file we are processing, simply
  remove the non-toplevel newlines and then feed the token stream into
  the pertinent parser.

* When we know the given toplevel declaration contains an expression, keep
  the newline tokens when feeding them to the parser.

## Indentation management

In expressions, newline tokens helps figure out indentation. When we know
we are parsing an expression, we need to selectively keep only the newline
tokens that are meaningfull (so as to not bloat the grammar with a bunch
of tokens that must be ignored).

Here is how to do it:

"scan" the token stream, keeping in memory a stack of identation level we
need to look for:

An expression of type:

```elm
case expr_5 of
  Http.BadUrl ptrn_3 ->
    expr_6

  Http.Timeout ->
    expr_7

  Http.NetworkError ->
    expr_8
```

will be translated in token form:

```
"case" /Expr/ "of" /Name/ /Ptn/ "->" /Expr/ "INDENT" /Name/ "->" /Expr/
"INDENT" /Name/ "->" /Expr/ "ENDOF"
```

* first pattern expression after an `of` keyword, add indent

* if there is anything following a `let`, add to the stack
  the column location of the beginning of that expression
  (currently it is impossible)

* first declaration after a `let`, add indent

* When encountering a `in`, pop all indents in the stack
  untill the corresponding `let` (the last one)

* when adding an indent that is lower than the current top of the stack,
  pop all indents greater that the new one

* eliminate all non-significant indents.

## Lazy parsing

To avoid needless computation (parsing expressions or type declaration), I
(plan to) only parse subsets of declarations and stock the remaining tokens
in a data structure so I can parse them later if needed.

# Terminal symbols

DocString
Name // a bare token, such as a variable or type names can have prefix
Operator
StringLit
Number
Character
( , ) { } [ ] -> | = : .. _
port module where exposing import
type alias case of if then else let in
N0 //Newline, with first character at column 0
Ny //Newline with specific indent

# Nonterminal symbols

/ModuleDeclr/ :=
 Name module Name where { <Name = Name>+ } exposing /ExportList/ N0
 port module Name exposing /ExportList/ N0
 module Name exposing /ExportList/ N0

/ExportList/ :=
 ( .. )
 (/ExportEntry/ <, /ExportEntry/>* )

/ExportEntry/ :=
 Name
 ( Operator )
 Name ( .. )
 Name ( Name <, Name>* )

/Import/ :=
 import Name <as Name>? <exposing /ExportList/>? N0

/TopDeclr/ :=
 infixr Number Operator N0
 infixl Number Operator N0
 DocString N0
 type alias Name <Name>* = /Type/ N0
 type Name <Name>* = Name </EnclosedType/>* <| Name </EnclosedType/>*>* N0
 port Name : /Type/ N0
 Name : /Type/ N0
 Name </Pattern/>* = /Expression/ N0
 ( Operator ) : /Type/ N0
 ( Operator ) </Pattern/>* = /Expression/ N0

/Type/ :=
 </FunctionlessType/ ->>* /FunctionlessType/

/FunctionlessType/ :=
 Name </EnclosedType/>+
 /EnclosedType/

/EnclosedType/ :=
 { }
 { <Name |>? Name : /Type/ <, Name : /Type/>* }
 ( /Type/ <, /Type/>+ )
 ( /Type/ )
 ( )
 Name

