module A exposing (..)

g x =
    case expr_1 of
        Ptrn_1 ->
            let
                ident_1 = expr_2
            in
                case expr_2 of
                    Ptrn_2 -> expr_3
                    Ptrn_3 -> expr_4
        Ptrn_4 ->
            expr_5

f x =
 let
     expr_1 =
         expr_2 (case expr_3 of
             Ok ptrn_1 ->
                 expr_4
             Err ptrn_2 ->
                 let
                     ident_1 =
                         case expr_5 of
                             Ptrn_8 ptrn_3 ->
                                 case expr_25 of
                                     Ptrn_1 ->
                                         expr_26
                                     Ptrn_2 ->
                                         expr_27
                                     Ptrn_3 ->
                                         expr_28

                             Ptrn_4 ->
                                 expr_7

                             Ptrn_5 ->
                                 expr_8

                             Ptrn_6 ptrn_4 ->
                                 expr_9

                             Ptrn_7 ptrn_5 ->
                                 expr_10
                 in
                    expr_11
         )
         (let ident_2 = expr_12 in expr_13)
         (expr_14)

     expr_15 =
         expr_16
             |> expr_17 expr_18

     expr_19 =
         expr_20
             |> expr_21 expr_22
 in
     ( expr_23, expr_24 )

-- The pre-parser was mistaking `case indent` for `let indent`
-- because of bad implementation
ident_1 : T1 T2 -> T3 T4 -> T5 -> ( T6, T7 T9 )
ident_1  ptrn_6 =
    let
        ident_3 =
            case expr_41 of
                Ptrn_8 ->
                    expr_26

                Ptrn_9 "" ->
                    expr_27

                Ptrn_10 ptrn_8 ->
                    if expr_37 /= expr_30 then
                        expr_32 expr_31
                    else
                       expr_36

        ident_41 =
            case expr_38 of
                Ptrn_13 "" ->
                    []

                Ptrn_14 ptrn_10 ->
                    expr_39
    in
        expr_40

-- Grammar prevented infixity in "in" clauses of
-- `let in` expressions directly inside `case` branches
ident_2 : T5 T6 -> T7 T8 (T12 T13) -> T15 T14 -> T16
ident_2 ptrn_11 ptrn_12 =
    case expr_41 of
        Just ptrn_14 ->
            case expr_42 of
                Just ptrn_15 ->
                    let
                        ident_4 =
                            expr_43
                    in
                       expr_44
                            |> expr_45
                                (\ptrn_16 ->
                                    expr_46
                                )

                Nothing ->
                    expr_47

        Nothing ->
            []

-- The parser didn't ignore correctly newlines generated by
-- line comments
ident_3 : T7 -> T8 T9 -> T10 -> T11 -> T12 -> T13 T14 -> T15T16
ident_3 ptrn_12 ptrn_13 ptrn_14 =
    if expr_45 || expr_46 || expr_47 then
        let
            --  This should break a poorly implemented
            -- parser :(
            ident_4 =
                expr_48
                    (\ptrn_15 ->
                        let
                            ident_5 =
                                if expr_49 then
                                   expr_50
                                else
                                   expr_51
                        in
                            expr_52 expr_53
                    )
        in
            case expr_54 of
                Just _ ->
                    if expr_55 == "" then
                       expr_57
                    else
                        expr_58

                Nothing ->
                    expr_59
    else
        expr_60


{-| The preparser should have been inserting the `indent` token *before*
The `endcase` tokens, while it was inserting it that the former-last
place.
The parser didn't handle correctly more than two levels of open case
closing when aligning to a lower level case
-}
ident_4 ident_5 =
    case expr_67 (expr_68 " ") of
        Ptrn_15 expr_69 ->
            case ptrn_19 of
                expr_71 ->
                    expr_72

                _ ->
                    case expr_70 of
                        Ptrn_16 ptrn_20 ->
                            case expr_83 of
                                Ptrn_17 ptrn_21 ->
                                    expr_84

                                Ptrn_18 ->
                                    expr_97

                        Ptrn_19 ->
                           expr_99

        Ptrn_20 ->
           expr_100


-- The parser didn't handle correctly more than two levels of open case
-- closing when closing an `in` delimiter.
ident_6 =
    case expr_110 of
        Ptrn_26 ->
            let
                ( ptrn_22, ptrn_21 ) =
                    case expr_104 of
                        Ptrn_21 ->
                            expr_105

                        Ptrn_22 ->
                            case
                                expr_103
                            of
                                Ptrn_24 ->
                                    expr_107

                                Ptrn_23 ->
                                    expr_106
            in
                expr_108

        Ptrn_25 ->
           expr_109

-- The grammar didn't concider `x :: y` as a proper pattern
ident_7 =
    case expr_111 of
        ptrn_23 :: ptrn_24 ->
            expr_112


-- You can start something on the "ident line" if it is an operator
ident_8 =
    case expr_1 of
        ptrn_1 -> expr_2
        ++ expr_3
        ptrn_2 -> expr_4


-- Alignement after `let` when `let` is the first token on the line
ident_9 =
    let ident_2 = expr_1
        ident_3 = expr_2
    in expr_3



-- infix `-` without whitespace after (bonus for float notation)
ident_10 = name-1e-10

-- prefix negation.
ident_11 = -10

-- Proper handling of alignement after `let`
-- (not intended to work)
-- ident_12 = let ident_2 = expr_1
--               ident_3 = expr_2
--           in expr_3

