#![allow(clippy)]
use std::str::FromStr;

use tokens;
use super::tree;
use self::tree::{
    TopDeclr,
    Expression,
    Expression_,
    Import,
    ExportEntry,
    ExportList,
    ModuleDeclr,
    OperPriority,
    LetDeclaration,
    Pattern,
    Type,
    TypeAlias,
    TypeDeclr,
    Associativity,
    Anchored,
    Literal,
};

grammar;

Spanned<Rule>: Anchored<Rule, tokens::Location> = {
    <l: @L> <rule: Rule> <r: @R> => ((l,r),rule),
};

pub ModuleDeclr: Option<ModuleDeclr> = {
    NameTok "module" <name:NameTok>
    "where" "{" NameTok "=" NameTok ("," NameTok "=" NameTok)* "}"
    "exposing" <exports:ExportList> =>
        Some(ModuleDeclr { <> }),

    "port" "module" <name:NameTok> "exposing" <exports:ExportList> =>
        Some(ModuleDeclr { <> }),

    "module" <name:NameTok> "exposing" <exports:ExportList> =>
        Some(ModuleDeclr { <> }),
     =>
        None,
};

ExportList: ExportList = {
    "(" ".." ")" => ExportList::Unqualified,
    "(" <Comma<ExportEntry>> ")" => ExportList::List(<>),
};

ExportEntry: ExportEntry = {
    NameTok => ExportEntry::Name(<>),
    "(" <OperatorTok> ")" => ExportEntry::Operator(<>),
    <NameTok> "(" ".." ")" => ExportEntry::WithAllConstructors(<>),
    <NameTok> "(" <Comma<NameTok>> ")" => ExportEntry::WithConstructors(<>),

};

pub Import: Import = {
    "import" <global_name:NameTok>
    <local_name:("as" <NameTok>)?>
    <exposes:("exposing" <ExportList>)?> => Import{ <> },
};


pub TopDeclr: TopDeclr<String,tokens::Location> = {
    "infixr" <precedence:NumberTok> <operator:OperatorTok> =>
        TopDeclr::OperPriority(OperPriority {
            associativity: Associativity::Right,
            precedence:
                u8::from_str(precedence.as_str())
                    .expect("Error reading precedence of infix operator"),
            operator : operator,
        }),

    "infixl" <precedence:NumberTok> <operator:OperatorTok> =>
        TopDeclr::OperPriority(OperPriority {
            associativity: Associativity::Left,
            precedence:
                // The lexer can potentially generate Number tokens that
                // are not convertible to u8, we "guard" against that
                // (this should be temporary untill I figure out a
                // better error handling system).
                u8::from_str(precedence.as_str())
                    .expect("Error reading precedence of infix operator"),
            operator : operator,
        }),

    "infix" <precedence:NumberTok> <operator:OperatorTok> =>
        TopDeclr::OperPriority(OperPriority {
            associativity: Associativity::Non,
            precedence:
                // The lexer can potentially generate Number tokens that
                // are not convertible to u8, we "guard" against that
                // (this should be temporary untill I figure out a
                // better error handling system).
                u8::from_str(precedence.as_str())
                    .expect("Error reading precedence of infix operator"),
            operator : operator,
        }),

    "infix" <kind:NameTok> <precedence:NumberTok> "(" <name:OperatorTok> ")"
    "=" <function:NameTok> => {
        let associativity = match kind.as_ref() {
            "left" => Associativity::Left,
            "right" => Associativity::Right,
            "non" => Associativity::Non,
            _ => panic!("Invalid operator precedence qualification :("),
        };
        let priority = OperPriority {
            associativity, operator: name.clone(),
            precedence:
                // The lexer can potentially generate Number tokens that
                // are not convertible to u8, we "guard" against that
                // (this should be temporary untill I figure out a
                // better error handling system).
                u8::from_str(precedence.as_str())
                    .expect("Error reading precedence of infix operator"),
        };
        TopDeclr::OperatorPrioDeclr { priority, function, name }
    },

    "type" <name:NameTok> <type_variables:NameTok*> "="
    <first_alt:(<NameTok> <EnclosedType*>)>
    <next_alts:("|"<NameTok> <EnclosedType*>)*> => {
        let mut alternatives : Vec<(String, Vec<Type>)> = next_alts;
        alternatives.insert(0,first_alt);
        TopDeclr::TypeDeclr(TypeDeclr{name,type_variables,alternatives})
    },

    "type" "alias" <name:NameTok> <type_variables:NameTok*> "=" <type_:Type> =>
        TopDeclr::TypeAlias(TypeAlias{name, type_variables, type_}),

    "(" <OperatorTok> ")" <EnclosedPattern*> "=" <Expression> =>
        TopDeclr::OperatorDeclr(<>),

    <p:"port"?> <name:NameTok> ":" <type_:Type> =>
        TopDeclr::FunctionAnnotation(p.is_some(), name,  type_),

    "(" <OperatorTok> ")" ":" <Type> =>
        TopDeclr::OperatorAnnotation(<>),

    <NameTok> <EnclosedPattern*> "=" <Expression> =>
        TopDeclr::FunctionDeclr(<>),

    <DocCommentTok> => TopDeclr::DocComment(<>),
};

Type: Type = {
    <args:(<FunctionlessType> "->")+> <returns:FunctionlessType> => {
        let mut function_types = args;
        function_types.push(returns);
        Type::Function(function_types)
    },

    FunctionlessType => <>,
};

FunctionlessType: Type = {
    NameTok EnclosedType+ => Type::Application(<>),
    EnclosedType => <>,
};

EnclosedType: Type = {
    <name:NameTok> =>
        if name.chars().nth(0).map(|x| x.is_lowercase()) == Some(true) {
            Type::Variable(name)
        } else {
            Type::Terminal(name)
        },

    "(" <entries:(<Type> ",")+> <last:Type> ")" => {
        let mut entries = entries;
        entries.push(last);
        Type::Tuple(entries)
    },

    "{" <variable_over:(<NameTok> "|")?>
    <fields:Comma<(<NameTok> ":" <Type>)>> "}" => {
        Type::Record(tree::Record { variable_over, fields })
    },

    "{" "}" => Type::EmptyRecord,
    "(" ")" => Type::UnitType,
    "(" <Type> ")" => <>,
};

Pattern: Pattern = {
    <entries:(<AppliPattern> OperatorTok)+> <last:AppliPattern> => {
        let mut entries = entries;
        entries.push(last);
        Pattern::Decons(entries)
    },

    AppliPattern => <>,
};

AppliPattern: Pattern = {
    <name:NameTok> <arguments:EnclosedPattern+> => {
        if name.chars().nth(0).map(|x| x.is_uppercase()) == Some(true) {
            Pattern::ArgConstructor(name, arguments)
        } else {
            panic!("A bind located at the place of constructor")
        }
    },

    EnclosedPattern => <>,
};

EnclosedPattern: Pattern = {
    "{" <Comma<NameTok>> "}" => // TODO: bind only to lowercase
        Pattern::Record(<>),

    "(" <p:Pattern> "as" <name:NameTok> ")" =>
        Pattern::AliasBind(name, Box::new(p)),

    "(" <entries:(<Pattern> ",")+> <last:Pattern> ")" => {
        let mut entries = entries;
        entries.push(last);
        Pattern::Tuple(entries)
    },

    <name:NameTok> =>
        if name.chars().nth(0).map(|x| x.is_lowercase()) == Some(true) {
            Pattern::Bind(name)
        } else {
            Pattern::Constructor(name)
        },

    "(" <Pattern> ")" => <>,
    "(" ")" => Pattern::UnitType,
    StringTok => Pattern::StringLit(<>),
    NumberTok => Pattern::Number(<>),
    CharTok => Pattern::Character(<>),
    "_" => Pattern::Discard,
    "[" "]" => Pattern::EmptyList,
    "[" <Comma<Pattern>> "]" => Pattern::List(<>),

};

Expression: Expression<String,tokens::Location> = Spanned<RawExpression>;
RawExpression: Expression_<String,tokens::Location> = {
    <prefixes:(<ApplicationExpression> <OperatorTok>)+>
    <trailing:OpenExpression> =>
        Expression_::InfixApplication{prefixes, trailing:Box::new(trailing)},

    RawOpenExpression => <>,
};

CaseExpression: Expression<String,tokens::Location> = Spanned<RawCaseExpression>;
RawCaseExpression: Expression_<String,tokens::Location> = {
    <prefixes:(<ApplicationExpression> <OperatorTok>)+>
    <trailing:CaseOpenExpression> =>
        Expression_::InfixApplication{prefixes, trailing:Box::new(trailing)},

    RawCaseOpenExpression => <>,
};

CaseOpenExpression: Expression<String,tokens::Location> = Spanned<RawCaseOpenExpression>;
RawCaseOpenExpression: Expression_<String,tokens::Location> = {
    "case" <condition:Expression> "of"
    <init:(<Pattern> "->" <CaseExpression> "case indent")*>
    <last:(<Pattern> "->" <CaseExpression>)> "endcase" => {
        let mut branches = init;
        branches.push(last);
        Expression_::CaseOf{condition:Box::new(condition), branches}
    },

    "lambda" <arguments:EnclosedPattern+> "->"
    <body:CaseExpression>  =>
        Expression_::Lambda{arguments, body:Box::new(body)},

    "if" <ife:Expression>
    "then" <thene:Expression>
    "else" <elsee:CaseExpression> =>
        Expression_::IfThenElse {
            condition: Box::new(ife),
            then_branch: Box::new(thene),
            else_branch: Box::new(elsee)
        },

    "let" <init:(<LetDeclaration> "let indent")*> <last:LetDeclaration>
    "in" <in_expr:CaseExpression> => {
        let mut declarations = init;
        declarations.push(last);
        Expression_::LetIn {
            declarations,
            expression: Box::new(in_expr)
        }
    },

    RawApplicationExpression => <>,
};

OpenExpression: Expression<String,tokens::Location> = Spanned<RawOpenExpression>;
RawOpenExpression: Expression_<String,tokens::Location> = {
    "case" <condition:Expression> "of"
    <init:(<Pattern> "->" <CaseExpression> "case indent")*>
    <last:(<Pattern> "->" <CaseExpression>)> => {
        let mut branches = init;
        branches.push(last);
        Expression_::CaseOf{condition:Box::new(condition), branches}
    },

    "lambda" <arguments:EnclosedPattern+> "->"
    <body:Expression>  =>
        Expression_::Lambda{arguments, body:Box::new(body)},

    "if" <ife:Expression>
    "then" <thene:Expression>
    "else" <elsee:Expression> =>
        Expression_::IfThenElse {
            condition: Box::new(ife),
            then_branch: Box::new(thene),
            else_branch: Box::new(elsee)
        },

    "let" <init:(<LetDeclaration> "let indent")*> <last:LetDeclaration>
    "in" <in_expr:Expression> => {
        let mut declarations = init;
        declarations.push(last);
        Expression_::LetIn {
            declarations,
            expression: Box::new(in_expr)
        }
    },

    RawApplicationExpression => <>,
};

ApplicationExpression: Expression<String,tokens::Location> = Spanned<RawApplicationExpression>;
RawApplicationExpression: Expression_<String,tokens::Location> = {
    <head:ClosedExpression> <tail:ClosedExpression+> => {
        let mut expressions = tail;
        expressions.insert(0,head);
        Expression_::Application(expressions)
    },

    RawClosedExpression => <>,
};

ClosedExpression: Expression<String,tokens::Location> = Spanned<RawClosedExpression>;
RawClosedExpression: Expression_<String,tokens::Location> = {
    "{" <updates:(<NameTok> "|")?>
    <fields:Comma<(<NameTok> "=" <Expression>)>> "}" =>
        Expression_::Record{<>},

    "[" <Comma<Expression>> "]" =>
        Expression_::List(<>),

    "(" <entries:(<Expression> ",")+> <last:Expression> ")" => {
        let mut entries = entries;
        entries.push(last);
        Expression_::Tuple(entries)
    },

    "(" <commas:","+> ")" =>
        Expression_::TupleConstructor((commas.len() + 1) as i16),

    "{" "}" => Expression_::Record {
        updates: None,
        fields: Vec::new(),
    },
    "[" "]" => Expression_::List(Vec::new()),
    "(" ")" => Expression_::Tuple(Vec::new()),
    "(" <RawExpression> ")" => <>,
    StringTok => Expression_::Literal(Literal::StringL, <>),
    NumberTok => Expression_::Literal(Literal::Number,<>),
    CharTok => Expression_::Literal(Literal::Char,<>),
    "(" <OperatorTok> ")" => Expression_::PrefixOperator(<>),
    NameTok => Expression_::Variable(<>),
};

LetDeclaration: LetDeclaration<String,tokens::Location> = {
    <annotation:(<NameTok> ":" <Type> "let indent")?>
    <name:NameTok> <arguments:EnclosedPattern+> "="
    <body:Expression> => {
        match annotation {
            Some((annot_name, maybe_annotation)) => {
                if annot_name != name {
                    // TODO: error handling
                    panic!("Type annotation name in let expression doesn't \
                           match the function declaration it is annotating")
                }
                let annotation = Some(maybe_annotation);
                LetDeclaration{
                    name: Some(name),
                    annotation, arguments, body
                }
            },
            None =>
                LetDeclaration{
                    name: Some(name),
                    annotation: None,
                    arguments, body
                },
        }
    },

    <annotation:(NameTok ":" <Type> "let indent")?>
    <pattern:EnclosedPattern> "=" <body:Expression> =>
        LetDeclaration{
            name: None,
            arguments: vec![pattern],
            annotation, body,
        },
};

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

extern {
    type Location = (u32,u16);
    type Error = tokens::LexError;

    enum tokens::ElmToken {
        "(" => tokens::ElmToken::LParens,
        ")" => tokens::ElmToken::RParens,
        "," => tokens::ElmToken::Comma,
        OperatorTok => tokens::ElmToken::Operator(<String>),
        ".." => tokens::ElmToken::Ellision,
        NameTok => tokens::ElmToken::Name(<String>),
        "module" => tokens::ElmToken::Module,
        "exposing" => tokens::ElmToken::Exposing,
        "import" => tokens::ElmToken::Import,
        "as" => tokens::ElmToken::As,
        "{" => tokens::ElmToken::LBrace,
        "}" => tokens::ElmToken::RBrace,
        DocCommentTok => tokens::ElmToken::DocComment(<String>),
        "[" => tokens::ElmToken::LBracket,
        "]" => tokens::ElmToken::RBracket,
        "lambda" => tokens::ElmToken::Lambda,
        "->" => tokens::ElmToken::RArrow,
        "case" => tokens::ElmToken::Case,
        "of" => tokens::ElmToken::Of,
        "_" => tokens::ElmToken::Underscore,
        "if" => tokens::ElmToken::If,
        "then" => tokens::ElmToken::Then,
        "else" => tokens::ElmToken::Else,
        "|" => tokens::ElmToken::Pipe,
        "=" => tokens::ElmToken::Assign,
        ":" => tokens::ElmToken::Colon,
        "type" => tokens::ElmToken::Type,
        "alias" => tokens::ElmToken::Alias,
        "infixr" => tokens::ElmToken::Infixr,
        "infixl" => tokens::ElmToken::Infixl,
        "infix" => tokens::ElmToken::Infix,
        "port" => tokens::ElmToken::Port,
        "where" => tokens::ElmToken::Where,
        "let" => tokens::ElmToken::Let,
        "in" => tokens::ElmToken::In,
        StringTok => tokens::ElmToken::StringLit(<String>),
        NumberTok => tokens::ElmToken::Number(<String>),
        CharTok => tokens::ElmToken::Char(<String>),
        "case indent" => tokens::ElmToken::CaseIndent,
        "let indent" => tokens::ElmToken::LetIndent,
        "endcase" => tokens::ElmToken::Endcase,
    }
}

// vim: ft=rust
