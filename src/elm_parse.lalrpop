use tokens;
use ast;
use std::str::FromStr;
use ast::TopDeclr;
use either::Either;

grammar;

pub ModuleDeclr: ast::ModuleDeclr = {
    NameTok "module" <name:NameTok>
    "where" "{" NameTok "=" NameTok ("," NameTok "=" NameTok)* "}"
    "exposing" <exports:ExportList> =>
        ast::ModuleDeclr { <> },

    "port" "module" <name:NameTok> "exposing" <exports:ExportList> =>
        ast::ModuleDeclr { <> },

    "module" <name:NameTok> "exposing" <exports:ExportList> =>
        ast::ModuleDeclr { <> },
};

ExportList: ast::ExportList = {
    "(" ".." ")" =>
        ast::ExportList::Unqualified,

    "(" <export_list:Comma<ExportEntry>> ")" =>
        ast::ExportList::List(export_list),
};

ExportEntry: ast::ExportEntry = {
    NameTok =>
        ast::ExportEntry::Name(<>),

    "(" <OperatorTok> ")" =>
        ast::ExportEntry::Operator(<>),

    <NameTok> "(" ".." ")" =>
        ast::ExportEntry::WithAllConstructors(<>),

    <name:NameTok> "(" <vals:Comma<NameTok>> ")" =>
        ast::ExportEntry::WithConstructors(name, vals),

};

pub Import: ast::ElmImport = {
    "import" <global_name:NameTok>
    <local_name:("as" <NameTok>)?>
    <exposes:("exposing" <ExportList>)?> =>
        ast::ElmImport{ <> },
};

pub TopDeclr: TopDeclr = {
    "infixr" <priority:NumberTok> <operator:OperatorTok> =>
        TopDeclr::OperPriority(ast::OperPriority {
            associativity: Either::Right(()),
            priority: u8::from_str(priority.as_str()).unwrap(),
            operator : operator,
        }),

    "infixl" <priority:NumberTok> <operator:OperatorTok> =>
        TopDeclr::OperPriority(ast::OperPriority {
            associativity: Either::Left(()),
            priority: u8::from_str(priority.as_str()).unwrap(),
            operator : operator,
        }),

    DocCommentTok =>
        TopDeclr::DocString(<>),

    "type" <name:NameTok> <type_variables:NameTok*> "="
    <first_alt:(<NameTok> <EnclosedType*>)>
    <next_alts:("|"<NameTok> <EnclosedType*>)*> => {
        let mut alternatives : Vec<(String, Vec<ast::Type>)> = next_alts;
        alternatives.insert(0,first_alt);
        TopDeclr::TypeDeclr(ast::TypeDeclr{name,type_variables,alternatives})
    },

    "type" "alias" <name:NameTok> <type_variables:NameTok*> "=" <type_:Type> =>
        TopDeclr::TypeAlias(ast::TypeAlias{<>}),
    "port" <NameTok> ":" <Type> =>
        TopDeclr::FunctionTypeDeclr(true, <>),
    <NameTok> ":" <Type> =>
        TopDeclr::FunctionTypeDeclr(false, <>),
    "(" <OperatorTok> ")" ":" <Type> =>
        TopDeclr::OperatorTypeDeclr(<>),
    <name:NameTok> <args:EnclosedPattern*> "=" (TokenList)* =>
        TopDeclr::FunctionDeclr(name, args),
    "(" <op:OperatorTok> ")" <args:EnclosedPattern*> "=" (TokenList)* =>
        TopDeclr::OperatorDeclr(op, args),
};

TokenList: tokens::ElmToken = {
    "(" => <>,
    ")" => <>,
    "," => <>,
    OperatorTok => tokens::ElmToken::Operator(<>),
    ".." => <>,
    NameTok => tokens::ElmToken::Name(<>),
    "module" => <>,
    "exposing" => <>,
    "import" => <>,
    "as" => <>,
    "{" => <>,
    "}" => <>,
    DocCommentTok => tokens::ElmToken::DocComment(<>),
    "[" => <>,
    "]" => <>,
    "lambda" => <>,
    "->" => <>,
    "case" => <>,
    "of" => <>,
    "_" => <>,
    "if" => <>,
    "then" => <>,
    "else" => <>,
    "|" => <>,
    "=" => <>,
    ":" => <>,
    "type" => <>,
    "alias" => <>,
    "infixr" => <>,
    "infixl" => <>,
    "port" => <>,
    "where" => <>,
    "let" => <>,
    "in" => <>,
    StringTok => tokens::ElmToken::StringLit(<>),
    NumberTok => tokens::ElmToken::Number(<>),
    CharTok => tokens::ElmToken::Char(<>),
    "\t" => <>,
};

Type: ast::Type = {
    <args:(<FunctionlessType> "->")+> <returns:FunctionlessType> => {
        let mut function_types = args;
        function_types.push(returns);
        ast::Type::Function(function_types)
    },

    FunctionlessType =>
        <>,
};

FunctionlessType: ast::Type = {
    <name:NameTok> <arguments:EnclosedType+> =>
        ast::Type::Application(name, arguments),

    <EnclosedType> =>
        <>,
};

EnclosedType: ast::Type = {
    <name:NameTok> =>
        if name.chars().nth(0).map(|x| x.is_lowercase()) == Some(true) {
            ast::Type::Variable(name)
        } else {
            ast::Type::Terminal(name)
        },

    "(" <entries:(<Type> ",")+> <last:Type> ")" => {
        let mut entries = entries;
        entries.push(last);
        ast::Type::Tuple(entries)
    },

    "{" <variable_over:(<NameTok> "|")?>
    <fields:Comma<(<NameTok> ":" <Type>)>> "}" => {
        ast::Type::Record(ast::Record { variable_over, fields })
    },

    "{" "}" => ast::Type::EmptyRecord,
    "(" ")" => ast::Type::UnitType,
    "(" <Type> ")" => <>,
};

Pattern: ast::Pattern = {
    <name:NameTok> <arguments:EnclosedPattern+> => {
        if name.chars().nth(0).map(|x| x.is_uppercase()) == Some(true) {
            ast::Pattern::ArgConstructor(name, arguments)
        } else {
            panic!("A bind located at the place of constructor")
        }
    },

    <EnclosedPattern> =>
        <>,
};

EnclosedPattern: ast::Pattern = {
    "{" <Comma<NameTok>> "}" => // TODO: bind only to lowercase
        ast::Pattern::Record(<>),

    "(" <p:Pattern> "as" <name:NameTok> ")" =>
        ast::Pattern::AliasBind(name, Box::new(p)),

    "(" <entries:(<Pattern> ",")+> <last:Pattern> ")" => {
        let mut entries = entries;
        entries.push(last);
        ast::Pattern::Tuple(entries)
    },

    <name:NameTok> =>
        if name.chars().nth(0).map(|x| x.is_lowercase()) == Some(true) {
            ast::Pattern::Bind(name)
        } else {
            ast::Pattern::Constructor(name)
        },

    "(" <entries:(<Pattern> OperatorTok)+> <last:Pattern> ")" => {
        let mut entries = entries;
        entries.push(last);
        ast::Pattern::Decons(entries)
    },

    "(" <Pattern> ")" => <>,
    "(" ")" => ast::Pattern::UnitType,
    StringTok => ast::Pattern::StringLit(<>),
    NumberTok => ast::Pattern::Number(<>),
    CharTok => ast::Pattern::Character(<>),
    "_" => ast::Pattern::Discard,
    "[" "]" => ast::Pattern::EmptyList,
    "[" <Comma<Pattern>> "]" => ast::Pattern::List(<>),

};

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

extern {
    type Location = usize;
    type Error = tokens::LexError;

    enum tokens::ElmToken {
        NewlineTok => tokens::ElmToken::Newline(<i16>,<i16>),
        "(" => tokens::ElmToken::LParens,
        ")" => tokens::ElmToken::RParens,
        "," => tokens::ElmToken::Comma,
        OperatorTok => tokens::ElmToken::Operator(<String>),
        ".." => tokens::ElmToken::Ellision,
        NameTok => tokens::ElmToken::Name(<String>),
        "module" => tokens::ElmToken::Module,
        "exposing" => tokens::ElmToken::Exposing,
        "import" => tokens::ElmToken::Import,
        "as" => tokens::ElmToken::As,
        "{" => tokens::ElmToken::LBrace,
        "}" => tokens::ElmToken::RBrace,
        DocCommentTok => tokens::ElmToken::DocComment(<String>),
        "[" => tokens::ElmToken::LBracket,
        "]" => tokens::ElmToken::RBracket,
        "lambda" => tokens::ElmToken::Lambda,
        "->" => tokens::ElmToken::RArrow,
        "case" => tokens::ElmToken::Case,
        "of" => tokens::ElmToken::Of,
        "_" => tokens::ElmToken::Underscore,
        "if" => tokens::ElmToken::If,
        "then" => tokens::ElmToken::Then,
        "else" => tokens::ElmToken::Else,
        "|" => tokens::ElmToken::Pipe,
        "=" => tokens::ElmToken::Assign,
        ":" => tokens::ElmToken::TypeDeclr,
        "type" => tokens::ElmToken::Type,
        "alias" => tokens::ElmToken::Alias,
        "infixr" => tokens::ElmToken::Infixr,
        "infixl" => tokens::ElmToken::Infixl,
        "port" => tokens::ElmToken::Port,
        "where" => tokens::ElmToken::Where,
        "let" => tokens::ElmToken::Let,
        "in" => tokens::ElmToken::In,
        StringTok => tokens::ElmToken::StringLit(<String>),
        NumberTok => tokens::ElmToken::Number(<String>),
        CharTok => tokens::ElmToken::Char(<String>),
        "\t" => tokens::ElmToken::Indent,
    }
}

// vim: ft=rust
