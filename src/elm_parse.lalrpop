use tokens;
use ast;
use std::str::FromStr;
use ast::TopDeclr;
use either::Either;

// #[recursive_ascent]
grammar;

pub ModuleDeclr: ast::ModuleDeclr = {
    NameTok "module" <name:NameTok>
    "where" "{" NameTok "=" NameTok ("," NameTok "=" NameTok)* "}"
    "exposing" <exports:ExportList> =>
        ast::ModuleDeclr { <> },

    "port" "module" <name:NameTok> "exposing" <exports:ExportList> =>
        ast::ModuleDeclr { <> },

    "module" <name:NameTok> "exposing" <exports:ExportList> =>
        ast::ModuleDeclr { <> },
};

ExportList: ast::ExportList = {
    "(" ".." ")" => ast::ExportList::Unqualified,
    "(" <Comma<ExportEntry>> ")" => ast::ExportList::List(<>),
};

ExportEntry: ast::ExportEntry = {
    NameTok => ast::ExportEntry::Name(<>),
    "(" <OperatorTok> ")" => ast::ExportEntry::Operator(<>),
    <NameTok> "(" ".." ")" => ast::ExportEntry::WithAllConstructors(<>),
    <NameTok> "(" <Comma<NameTok>> ")" => ast::ExportEntry::WithConstructors(<>),

};

pub Import: ast::ElmImport = {
    "import" <global_name:NameTok>
    <local_name:("as" <NameTok>)?>
    <exposes:("exposing" <ExportList>)?> =>
        ast::ElmImport{ <> },
};

pub TopDeclr: TopDeclr = {
    "infixr" <priority:NumberTok> <operator:OperatorTok> =>
        TopDeclr::OperPriority(ast::OperPriority {
            associativity: Either::Right(()),
            priority: u8::from_str(priority.as_str()).unwrap(),
            operator : operator,
        }),

    "infixl" <priority:NumberTok> <operator:OperatorTok> =>
        TopDeclr::OperPriority(ast::OperPriority {
            associativity: Either::Left(()),
            priority: u8::from_str(priority.as_str()).unwrap(),
            operator : operator,
        }),

    "type" <name:NameTok> <type_variables:NameTok*> "="
    <first_alt:(<NameTok> <EnclosedType*>)>
    <next_alts:("|"<NameTok> <EnclosedType*>)*> => {
        let mut alternatives : Vec<(String, Vec<ast::Type>)> = next_alts;
        alternatives.insert(0,first_alt);
        TopDeclr::TypeDeclr(ast::TypeDeclr{name,type_variables,alternatives})
    },

    "type" "alias" <name:NameTok> <type_variables:NameTok*> "=" <type_:Type> =>
        TopDeclr::TypeAlias(ast::TypeAlias{<>}),

    "(" <OperatorTok> ")" <EnclosedPattern*> "=" <Expression> =>
        TopDeclr::OperatorDeclr(<>),

    <p:"port"?> <name:NameTok> ":" <type_:Type> =>
        TopDeclr::FunctionAnnotation(p.is_some(), name,  type_),

    "(" <OperatorTok> ")" ":" <Type> =>
        TopDeclr::OperatorAnnotation(<>),

    <NameTok> <EnclosedPattern*> "=" <Expression> =>
        TopDeclr::FunctionDeclr(<>),

    DocCommentTok => TopDeclr::DocString(<>),
};

TokenList: tokens::ElmToken = {
    "(" => <>,
    ")" => <>,
    "," => <>,
    OperatorTok => tokens::ElmToken::Operator(<>),
    ".." => <>,
    NameTok => tokens::ElmToken::Name(<>),
    "module" => <>,
    "exposing" => <>,
    "import" => <>,
    "as" => <>,
    "{" => <>,
    "}" => <>,
    DocCommentTok => tokens::ElmToken::DocComment(<>),
    "[" => <>,
    "]" => <>,
    "lambda" => <>,
    "->" => <>,
    "case" => <>,
    "of" => <>,
    "_" => <>,
    "if" => <>,
    "then" => <>,
    "else" => <>,
    "|" => <>,
    "=" => <>,
    ":" => <>,
    "type" => <>,
    "alias" => <>,
    "infixr" => <>,
    "infixl" => <>,
    "port" => <>,
    "where" => <>,
    "let" => <>,
    "in" => <>,
    StringTok => tokens::ElmToken::StringLit(<>),
    NumberTok => tokens::ElmToken::Number(<>),
    CharTok => tokens::ElmToken::Char(<>),
    "let indent" => <>,
    "case indent" => <>,
    "endcase" => <>,
};

Type: ast::Type = {
    <args:(<FunctionlessType> "->")+> <returns:FunctionlessType> => {
        let mut function_types = args;
        function_types.push(returns);
        ast::Type::Function(function_types)
    },

    FunctionlessType => <>,
};

FunctionlessType: ast::Type = {
    NameTok EnclosedType+ => ast::Type::Application(<>),
    EnclosedType => <>,
};

EnclosedType: ast::Type = {
    <name:NameTok> =>
        if name.chars().nth(0).map(|x| x.is_lowercase()) == Some(true) {
            ast::Type::Variable(name)
        } else {
            ast::Type::Terminal(name)
        },

    "(" <entries:(<Type> ",")+> <last:Type> ")" => {
        let mut entries = entries;
        entries.push(last);
        ast::Type::Tuple(entries)
    },

    "{" <variable_over:(<NameTok> "|")?>
    <fields:Comma<(<NameTok> ":" <Type>)>> "}" => {
        ast::Type::Record(ast::Record { variable_over, fields })
    },

    "{" "}" => ast::Type::EmptyRecord,
    "(" ")" => ast::Type::UnitType,
    "(" <Type> ")" => <>,
};

Pattern: ast::Pattern = {
    <name:NameTok> <arguments:EnclosedPattern+> => {
        if name.chars().nth(0).map(|x| x.is_uppercase()) == Some(true) {
            ast::Pattern::ArgConstructor(name, arguments)
        } else {
            panic!("A bind located at the place of constructor")
        }
    },

    <entries:(<EnclosedPattern> OperatorTok)+> <last:EnclosedPattern> => {
        let mut entries = entries;
        entries.push(last);
        ast::Pattern::Decons(entries)
    },

    EnclosedPattern => <>,
};

EnclosedPattern: ast::Pattern = {
    "{" <Comma<NameTok>> "}" => // TODO: bind only to lowercase
        ast::Pattern::Record(<>),

    "(" <p:Pattern> "as" <name:NameTok> ")" =>
        ast::Pattern::AliasBind(name, Box::new(p)),

    "(" <entries:(<Pattern> ",")+> <last:Pattern> ")" => {
        let mut entries = entries;
        entries.push(last);
        ast::Pattern::Tuple(entries)
    },

    <name:NameTok> =>
        if name.chars().nth(0).map(|x| x.is_lowercase()) == Some(true) {
            ast::Pattern::Bind(name)
        } else {
            ast::Pattern::Constructor(name)
        },

    "(" <Pattern> ")" => <>,
    "(" ")" => ast::Pattern::UnitType,
    StringTok => ast::Pattern::StringLit(<>),
    NumberTok => ast::Pattern::Number(<>),
    CharTok => ast::Pattern::Character(<>),
    "_" => ast::Pattern::Discard,
    "[" "]" => ast::Pattern::EmptyList,
    "[" <Comma<Pattern>> "]" => ast::Pattern::List(<>),

};

Expression: ast::Expression = {
    <prefix:(<ApplicationExpression> <OperatorTok>)+> <last:OpenExpression> =>
        ast::Expression::InfixApplication(prefix, Box::from(last)),

    OpenExpression => <>,
};

EsacExpression: ast::Expression = {
    <prefix:(<ApplicationExpression> <OperatorTok>)+>
    <last:EsacOpenExpression> =>
        ast::Expression::InfixApplication(prefix, Box::from(last)),

    EsacOpenExpression => <>,
};

EsacOpenExpression: ast::Expression = {
    "case" <expr:Expression> "of"
    <init:(<Pattern> "->" <EsacExpression> "case indent")*>
    <last:(<Pattern> "->" <EsacExpression>)> "endcase" => {
        let mut branches = init;
        branches.push(last);
        ast::Expression::CaseOf(Box::from(expr), branches)
    },

    "lambda" <patterns:EnclosedPattern+> "->" <expr:EsacExpression>  =>
        ast::Expression::Lambda(patterns, Box::from(expr)),

    "if" <ife:Expression>
    "then" <thene:Expression>
    "else" <elsee:EsacExpression> =>
        ast::Expression::IfThenElse(
            Box::from(ife),
            Box::from(thene),
            Box::from(elsee)
        ),

    "let" <init:(<LetDeclaration> "let indent")*> <last:LetDeclaration>
    "in" <in_expr:EsacExpression> => {
        let mut declarations = init;
        declarations.push(last);
        ast::Expression::LetIn(declarations, Box::from(in_expr))
    },

    ApplicationExpression => <>,
};

OpenExpression: ast::Expression = {
    "case" <expr:Expression> "of"
    <init:(<Pattern> "->" <EsacExpression> "case indent")*>
    <last:(<Pattern> "->" <EsacExpression>)> => {
        let mut branches = init;
        branches.push(last);
        ast::Expression::CaseOf(Box::from(expr), branches)
    },

    "lambda" <patterns:EnclosedPattern+> "->" <expr:Expression>  =>
        ast::Expression::Lambda(patterns, Box::from(expr)),

    "if" <ife:Expression>
    "then" <thene:Expression>
    "else" <elsee:Expression> =>
        ast::Expression::IfThenElse(
            Box::from(ife),
            Box::from(thene),
            Box::from(elsee)
        ),

    "let" <init:(<LetDeclaration> "let indent")*> <last:LetDeclaration>
    "in" <in_expr:Expression> => {
        let mut declarations = init;
        declarations.push(last);
        ast::Expression::LetIn(declarations, Box::from(in_expr))
    },

    ApplicationExpression => <>,
};

ApplicationExpression: ast::Expression = {
    <head:ClosedExpression> <tail:ClosedExpression+> => {
        let mut expressions = tail;
        expressions.insert(0,head);
        ast::Expression::Application(expressions)
    },

    ClosedExpression => <>,
};

ClosedExpression: ast::Expression = {
    "{" <(<NameTok> "|")?> <Comma<(<NameTok> "=" <Expression>)>> "}" =>
        ast::Expression::Record(<>),

    "[" <Comma<Expression>> "]" =>
        ast::Expression::List(<>),

    "(" <entries:(<Expression> ",")+> <last:Expression> ")" => {
        let mut entries = entries;
        entries.push(last);
        ast::Expression::Tuple(entries)
    },

    "(" <commas:","+> ")" =>
        ast::Expression::TupleConstructor((commas.len() + 1) as i16),

    "{" "}" => ast::Expression::EmptyRecord,
    "[" "]" => ast::Expression::EmptyList,
    "(" ")" => ast::Expression::UnitType,
    "(" <Expression> ")" => <>,
    StringTok => ast::Expression::StringLit(<>),
    NumberTok => ast::Expression::Number(<>),
    CharTok => ast::Expression::Character(<>),
    "(" <OperatorTok> ")" => ast::Expression::PrefixOperator(<>),
    NameTok => ast::Expression::Variable(<>),
};

LetDeclaration: Either<ast::LetDeclaration,ast::LetBind> = {
    <annotation:(<NameTok> ":" <Type> "let indent")?>
    <name:NameTok> <arguments:EnclosedPattern+> "=" <body:Expression> => {
        match annotation {
            Some((annot_name, maybe_annotation)) => {
                if annot_name != name {
                    panic!("Type annotation name in let expression doesn't \
                           match the function declaration it is annotating")
                }
                let annotation = Some(maybe_annotation);
                Either::Left(
                    ast::LetDeclaration{annotation, name, arguments, body}
                )
            },
            None => {
                Either::Left(
                    ast::LetDeclaration{annotation:None, name, arguments, body}
                )
            },
        }
    },

    <pattern:EnclosedPattern> "=" <body:Expression> =>
        Either::Right(ast::LetBind{<>}),
};

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

extern {
    type Location = usize;
    type Error = tokens::LexError;

    enum tokens::ElmToken {
        NewlineTok => tokens::ElmToken::Newline(<i16>,<i16>),
        "(" => tokens::ElmToken::LParens,
        ")" => tokens::ElmToken::RParens,
        "," => tokens::ElmToken::Comma,
        OperatorTok => tokens::ElmToken::Operator(<String>),
        ".." => tokens::ElmToken::Ellision,
        NameTok => tokens::ElmToken::Name(<String>),
        "module" => tokens::ElmToken::Module,
        "exposing" => tokens::ElmToken::Exposing,
        "import" => tokens::ElmToken::Import,
        "as" => tokens::ElmToken::As,
        "{" => tokens::ElmToken::LBrace,
        "}" => tokens::ElmToken::RBrace,
        DocCommentTok => tokens::ElmToken::DocComment(<String>),
        "[" => tokens::ElmToken::LBracket,
        "]" => tokens::ElmToken::RBracket,
        "lambda" => tokens::ElmToken::Lambda,
        "->" => tokens::ElmToken::RArrow,
        "case" => tokens::ElmToken::Case,
        "of" => tokens::ElmToken::Of,
        "_" => tokens::ElmToken::Underscore,
        "if" => tokens::ElmToken::If,
        "then" => tokens::ElmToken::Then,
        "else" => tokens::ElmToken::Else,
        "|" => tokens::ElmToken::Pipe,
        "=" => tokens::ElmToken::Assign,
        ":" => tokens::ElmToken::TypeDeclr,
        "type" => tokens::ElmToken::Type,
        "alias" => tokens::ElmToken::Alias,
        "infixr" => tokens::ElmToken::Infixr,
        "infixl" => tokens::ElmToken::Infixl,
        "port" => tokens::ElmToken::Port,
        "where" => tokens::ElmToken::Where,
        "let" => tokens::ElmToken::Let,
        "in" => tokens::ElmToken::In,
        StringTok => tokens::ElmToken::StringLit(<String>),
        NumberTok => tokens::ElmToken::Number(<String>),
        CharTok => tokens::ElmToken::Char(<String>),
        "case indent" => tokens::ElmToken::CaseIndent,
        "let indent" => tokens::ElmToken::LetIndent,
        "endcase" => tokens::ElmToken::Endcase, // Dying of calling it "esac"
    }
}

// vim: ft=rust
